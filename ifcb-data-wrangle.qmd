---
title: "ifcb-port aransas"
format:
  html:
    code-fold: show
    code-tools: true
    code-copy: true
    toc: true
    toc-location: left
    number-sections: true
    number-depth: 2
editor: visual
---

# Set-up

```{r, warning=FALSE}
# | warning: false
# | message: false
library(tidyverse)
library(patchwork)
library(svglite)
library(scales)
library(treemapify)
```

# Preliminary input data

All data from Port Aransas. Counts by hour. Remove data before January 1 2008, as it was newly deployed and has some inconsistencies. Also using lubridate to convert to R-friendly date/time formats.

> Go back and ensure carbon units and time zone!

```{r}
counts <- read.csv("input-data/counts_hourly_Hu.csv") |> 
  # Use lubridate package to assign "date" format.
  mutate(DAY = ymd_hms(X)) %>% 
  mutate(DATE = date(DAY),
         MONTH = month(DAY),
         HOUR = hour(DAY)) %>% 
  select(DAY, DATE, MONTH, HOUR, everything(), -X) %>% 
  filter(as_date(DAY) >= as_date("2008-01-01") & 
           as_date(DAY) <= as_date("2017-08-24"))
# glimpse(counts)
range(counts$DAY)
# head(counts)
```

Carbon biomass by day.

```{r}
carbon <- read.csv("input-data/carbon_hourly.csv") %>% 
  mutate(DAY = ymd_hms(X)) %>% 
  mutate(DATE = date(DAY),
         MONTH = month(DAY),
         HOUR = hour(DAY)) %>% 
  select(DAY, DATE, MONTH, HOUR, everything(), -X) %>% 
  filter(as_date(DAY) >= as_date("2008-01-01") & 
           as_date(DAY) <= as_date("2017-08-24"))
# head(carbon)

range(carbon$DAY)
# glimpse(carbon)
```

Subset so dataset includes "2008-01-01" to "2017-08-24".

### Export taxa names for manual curation

Export for manual curation

```{r}
# tax_export <- counts %>% 
#     pivot_longer(cols = -c(DAY), names_to = "CELL_ID", values_to = "COUNT") %>% #Add in time here when we have it.
#     select(CELL_ID) %>% distinct()
```

## Refine input data

## Add taxa curated to cell IDs and carbon data

Siddarth contributed to this taxa list.

```{r}
tax_curated <- read.csv("input-data/tax-list.csv") |>
  select(CELL_ID:Species) 
```


Add to cell ID information

```{r}
counts_long_wtax <- counts %>% 
  pivot_longer(cols = -c(DAY, DATE, MONTH, HOUR), names_to = "CELL_ID", values_to = "COUNT", values_drop_na = TRUE) %>% 
  filter(COUNT > 0) %>% 
  left_join(tax_curated)

# head(counts_long_wtax)
# range(counts_long_wtax$COUNT)
```

Add to carbon data

```{r}
carbon_long_wtax <- carbon %>% 
  pivot_longer(cols = -c(DAY, DATE, MONTH, HOUR), names_to = "CELL_ID", values_to = "CARBON", values_drop_na = TRUE) %>% 
  filter(CARBON > 0) %>% 
  left_join(tax_curated)

# head(carbon_long_wtax)
# range(carbon_long_wtax$CARBON)
```



Types of classifications in dataset.
```{r}
table(counts_long_wtax$COURSE_CLASSIFICATION)
table(counts_long_wtax$TYPE)
# glimpse(counts_long_wtax)

# table(carbon_long_wtax$COURSE_CLASSIFICATION)
```

## Save / import data locally

```{r}
# save(counts_long_wtax, carbon_long_wtax, file = "input-data/compiled_data_input.RData")
```

Pick up here to work locally.

```{r}
load("input-data/compiled_data_input.RData", verbose = TRUE)
```


We need the date/time information from the IFCB outputs to be similar to the metadata for statistical work. 
```{r}
head(counts_long_wtax)
```



# Import Gulf metadata

Metadata information compiled by Siddarth Seshampally.

## TABS Buoy D

Import and compile data for TABS Buoy D from "Ocean Data". Downloaded as individual years.

First isolate downloaded files.

```{r}
ocean_data_files <- list.files(path = "input-data/TABS_D/", pattern = "Ocean Data ", full.names = TRUE)

# Make sure it works
ocean_data_files
# The full.names = TRUE means that it will output the whole path. This is what we want!
```

Let's test out how to import one of these files so we can write an effective function below.

```{r}
test <- read.table(
  "input-data/TABS_D/Ocean Data 2010.txt", #Use read.table, because columns were separated by either 1 or more spaces. 
  comment.char = "", # Tell R that the "#" in line 1 and 2 needs to be read, instead of ignored.
  skip = 1, #Skip the first line, because there are 2 "headers"
  header = TRUE # make sure the first column is read in as a column header.
  )
head(test)
# ?read.table

# We will want to fix the column headers below, so let's try it. 
# YY  MM DD hh mm   DEPTH  OTMP   COND   SAL   O2% O2PPM  CLCON  TURB    PH    EH

test_headers <- test |> 
  select(YEAR = X.yr,
         MONTH = mo,
         DAY = dy,
         HOUR = hr,
         MINUTE = mn,
         DEPTH_m = m,
         TEMP_degC = degC,
         COND_mS_cm = mS.cm,
         SAL_psu = psu,
         O2_perc = X.,
         O2_PPM = ppm,
         Cl_ug_l = ug.l,
         TURB_FTU = FTU,
         pH = X..1,
         EH = mv)
## This is where you will want to review the data you collected. And remember R is really basic when it comes to reading in spaces and special characters. So we should make more meaningful column headers.
head(test_headers)
```

```         
#YY  MM DD hh mm   DEPTH  OTMP   COND   SAL   O2% O2PPM  CLCON  TURB    PH    EH
#yr  mo dy hr mn       m  degC  mS/cm   psu     %   ppm   ug/l   FTU     -    mv
2010 01 01 00 00     2.0 14.70 999.00 99.00 999.0 99.00 999.00    99 99.00 99.00
2010 01 01 00 30     2.0 14.70 999.00 99.00 999.0 99.00 999.00    99 99.00 99.00
```

*Columns should be:* YY MM DD hh mm DEPTH OTMP COND SAL O2% O2PPM CLCON TURB PH EH

We can test out and build each line of the function using more examples with `ocean_data_files[1]`

```{r}
i <- ocean_data_files[1]
# i
# Isolate each file name, so we can get the year information.
strip_name <- unlist(strsplit(i, " "))
year <- str_remove(strip_name[3], ".txt")
year
```

Write a function to import each file, modify it, and anneal it to itself.

```{r}
rm(in_data); rm(new_table)
# The i will be our variable in the function. This "for" statement will reach each item in the "ocean_data_files" file list.
for (i in ocean_data_files){
  in_data <- read.table(i, 
  comment.char = "", skip = 1, header = TRUE)
  # Get year information.
  strip_name <- unlist(strsplit(i, " "))
  year <- str_remove(strip_name[3], ".txt")
  # Add as a column
  in_data$YEAR <- year
  # Write an if else statement to combine all data.
  if (!exists("new_table")){
    new_table <- in_data
  } else {
    new_table <- rbind(new_table, in_data)
  }
  rm(in_data)
}

# Check out the new table
head(new_table)

# All years?
unique(new_table$YEAR)
```

Fix column headers now. Note that for this data, YEAR was listed twice. We can clean it up now. But it is an example of how to parse file names for dataframe information.

```{r}
ocean_data_dfs <- new_table |> 
  select(YEAR = `X.yr`,
       MONTH = mo,
       DAY = dy,
       HOUR = hr,
       MINUTE = mn,
       DEPTH_m = m,
       TEMP_degC = degC,
       COND_mS_cm = `mS.cm`,
       SAL_psu = psu,
       O2_perc = `X.`,
       O2_PPM = ppm,
       Cl_ug_l = `ug.l`,
       TURB_FTU = FTU,
       pH = `X..1`,
       EH = mv)
colnames(ocean_data_dfs)
```

## Make plots with ocean data

```{r}
ocean_data_dfs_long <- ocean_data_dfs |> 
  pivot_longer(cols = -c(YEAR, MONTH, DAY, HOUR, MINUTE), names_to = "VARIABLE", values_to = "VALUE") |> 
  unite(date, YEAR, MONTH, DAY, sep = "-", remove = FALSE) |>
  unite(month_day, MONTH, DAY, sep = "-", remove = FALSE) |> 
  unite(time, HOUR, MINUTE, sep = ":") |> 
  # Artificially make a column of dates that have the same year (it needs to be a leap year).
  mutate(GRAPH_DATE = as.Date(paste("2012", month(date),mday(date), sep = "-")))

head(ocean_data_dfs_long)
```

When data are in long format it is easier to make lots of plots. Use the next two sets of commands to look at the data and variables.

```{r}
range(ocean_data_dfs$TEMP_degC)
# hist(ocean_data_dfs$TURB_FTU)
# range(ocean_data_dfs$TURB_FTU)
```

```{r}
unique(ocean_data_dfs_long$VARIABLE)
head(ocean_data_dfs_long)
```

### Temperature by year

```{r, fig.height=8, fig.width=15}

ocean_data_dfs_long |> 
  filter(VARIABLE == "TEMP_degC") |> 
  filter(VALUE < 99) |> 
  mutate(YEAR = as.character(YEAR)) |> 
  group_by(YEAR, date, GRAPH_DATE) |> 
    summarise(TEMP_MEAN = mean(VALUE),
              TEMP_MIN = min(VALUE),
              TEMP_MAX = max(VALUE)) |> 
  ggplot(aes(x = GRAPH_DATE, y = TEMP_MEAN, group = YEAR, color = YEAR)) +
  scale_x_date(labels = scales::date_format("%m/%d")) +
  geom_point(shape = 16, size = 2) +
  geom_errorbar(aes(x = GRAPH_DATE, ymin = TEMP_MIN, ymax = TEMP_MAX)) +
  scale_color_brewer(palette = "Set2") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 0, face = "bold", color = "black", hjust = 0.5, vjust = 1, size = 24),
    axis.text.y = element_text(color = "black", face = "bold", size = 24),
    axis.title = element_text(color = "black", face = "bold", size = 24)) +
  labs(x = "Date", y = "Temperature Â°C")
```

# Import historical data

> With with Siddarth

From TABs curators.

```{r}
# tabs_d <- read.delim(file = "../../../Downloads/tabs_D_salt.asc", sep = "", header = FALSE, strip.white = TRUE) |> 
#   select(DATE = V1, TIME_UTC = V2, TEMP = V3, CONDUCT = V4, SALT = V5, -V6, -V7)
```



# IFCB data overview

Make a bar plot of the course classification types available from the IFCB.

```{r, fig.height=4, fig.width=6}
counts_long_wtax |> 
  group_by(COURSE_CLASSIFICATION, TYPE) |> 
  summarise(COUNT = n()) |> 
  ggplot(aes(area = COUNT, fill = COURSE_CLASSIFICATION)) +
  geom_treemap(color = "white") +
  facet_grid(rows = vars(TYPE)) +
  theme_classic()
```

Repeat with only microeukaryotes

```{r, fig.height=4, fig.width=6}
counts_long_wtax |> 
  filter(COURSE_CLASSIFICATION == "Microeukaryote") |> 
  group_by(Supergroup, Phylum) |> 
    summarise(SUM = sum(COUNT),
              COUNT = n()) |> 
  ggplot(aes(x = Supergroup, y = SUM, fill = Phylum)) +
  geom_bar(stat = "identity", color = "black") +
  coord_flip() +
  theme_classic() +
  labs(y = "Sum of cell counts", x = "Supergroup")
```

## Groups by carbon biomass

```{r, fig.height=4, fig.width=6}
carbon_long_wtax |> 
  filter(COURSE_CLASSIFICATION == "Microeukaryote") |> 
  group_by(Supergroup, Phylum) |> 
    summarise(SUM = sum(CARBON)) |> 
  ggplot(aes(x = Supergroup, y = SUM, fill = Phylum)) +
  geom_bar(stat = "identity", color = "black") +
  coord_flip() +
  theme_classic() +
  labs(y = "Sum of carbon biomass", x = "Supergroup")
```

```{r}
# counts_long_wtax %>% 
  # select(COURSE_CLASSIFICATION, TYPE, Domain, Supergroup, Phylum) %>% 
  # distinct()
# unique(counts_long_wtax$COURSE_CLASSIFICATION)
```


### Breakdown Alveolata

```{r}
head(counts_long_wtax)
```


```{r, fig.height=5, fig.width=6}
counts_long_wtax |> 
  filter(Supergroup == "Alveolata") |> 
  group_by(Phylum, Class, Order) |> 
    summarise(SUM = sum(COUNT),
              COUNT = n()) |> 
  ggplot(aes(area = SUM, fill = Class, subgroup = Order, label = Order)) +
  geom_treemap(color = "white") +
  geom_treemap_subgroup_border(color = "grey") +
    geom_treemap_text(place = "centre",size = 12) + 
  theme_classic() +
  labs(title = "Most abundant Alveolata")
```

```{r, fig.height=5, fig.width=6}
carbon_long_wtax |> 
  filter(Supergroup == "Alveolata") |> 
  group_by(Phylum, Class, Order) |> 
    summarise(SUM_CARBON = sum(CARBON)) |> 
  ggplot(aes(area = SUM_CARBON, fill = Class, subgroup = Order, label = Order)) +
  geom_treemap(color = "white") +
  geom_treemap_subgroup_border(color = "grey") +
    geom_treemap_text(place = "centre",size = 12) + 
  theme_classic() +
  labs("Alveolata by carbon")
```


### Breakdown Stramenopiles

```{r}
head(counts_long_wtax)
```


```{r, fig.height=5, fig.width=6}
counts_long_wtax |> 
  filter(Supergroup == "Stramenopiles") |> 
  group_by(Phylum, Class, Order) |> 
    summarise(SUM = sum(COUNT),
              COUNT = n()) |> 
  ggplot(aes(area = SUM, fill = Class, subgroup = Order, label = Order)) +
  geom_treemap(color = "white") +
  geom_treemap_subgroup_border(color = "grey") +
    geom_treemap_text(place = "centre",size = 12) + 
  theme_classic() +
  labs(title = "Most abundant Stramenopiles")
```

```{r, fig.height=5, fig.width=6}
carbon_long_wtax |> 
  filter(Supergroup == "Stramenopiles") |> 
  group_by(Phylum, Class, Order) |> 
    summarise(SUM_CARBON = sum(CARBON)) |> 
  ggplot(aes(area = SUM_CARBON, fill = Class, subgroup = Order, label = Order)) +
  geom_treemap(color = "white") +
  geom_treemap_subgroup_border(color = "grey") +
    geom_treemap_text(place = "centre",size = 12) + 
  theme_classic() +
  labs(title = "Stramenopiles by carbon")
```


## Add seasons

# Make data frames to assign season

Spring = March 1 - May 31 Summer = June 1 - Aug 31 Fall = Sept 1 - Nov 30 Winter = Dec 1 - Feb (March 1 (-1))

Make a new dataframe to just add seasons (manually) to the date. I'm subsetting to 2024 to include leap day years. 

```{r}
df_season <- counts %>% 
  pivot_longer(cols = -c(DAY, DATE, MONTH, HOUR), names_to = "CELL_ID", values_to = "COUNT") %>%
  mutate(DATA_GAP = case_when(
    is.na(COUNT) ~ "Missing",
    TRUE ~ "Not missing"
  )) |> 
  mutate(date_tmp =  as.Date(format(DAY, '2024-%m-%d')), 
        SEASON = case_when(between(date_tmp, ymd('2024-03-01'), ymd('2024-05-31')) ~ "Spring",
                           between(date_tmp, ymd('2024-06-01'), ymd('2024-08-31')) ~ "Summer", 
                           between(date_tmp, ymd('2024-09-01'), ymd('2024-11-30')) ~ "Fall", 
                           TRUE ~ "Winter")) %>% # Winter needs to be "else" because you can't select between.
  select(DAY, date_tmp, SEASON, DATA_GAP) |> distinct() |> 
  mutate(YEAR = year(DAY),
         MONTH = month(DAY),
         DATE = day(DAY),
         HOUR = hour(DAY)) |> 
  group_by(SEASON) |> 
  mutate(month_start_tmp = case_when(
    SEASON == "Winter" ~ max(MONTH),
    TRUE ~ min(MONTH)),
    year_start_tmp = case_when(SEASON == "Winter" ~ YEAR - 1,
                               TRUE ~ YEAR),
    ) |> 
  mutate(month_end_tmp = case_when(
    SEASON == "Winter" ~ 2,
    TRUE ~ max(MONTH))) |> 
  group_by(SEASON, MONTH) |> 
  mutate(day_start_tmp = min(day(DAY)),
         day_end_tmp = case_when(
           (SEASON == "Winter" & leap_year(YEAR) == TRUE) ~ 29,
           (SEASON == "Winter" & leap_year(YEAR) == FALSE) ~ 28,
           (SEASON == "Summer" | SEASON == "Spring") ~ 31,
           SEASON == "Fall" ~ 30
         )) |> 
  ungroup() |> 
  unite("start", year_start_tmp, month_start_tmp, day_start_tmp, sep = "-", remove = FALSE) |> 
  unite("end", YEAR, month_end_tmp, day_end_tmp, sep = "-", remove = FALSE) |> 
  mutate(START = ymd(start),
         END = ymd(end),
         START_noy = mdy(paste(month(START), day(START), "2024", sep = "-")),
         END_noy = mdy(paste(month(END), day(END), "2024", sep = "-"))) |> 
  select(DAY, DATE, MONTH, YEAR, HOUR, SEASON, START, END, START_noy, END_noy) |> distinct()

# head(df_season)
# View(df_season |> select(SEASON, START, END) |> distinct())
df_oneyear <- df_season |> 
  mutate(DATE = mdy(paste(month(DAY), day(DAY), "2024", sep = "-"))) |> 
  select(SEASON, START_noy, END_noy, DATE) |> 
  # filter(!(SEASON == "Winter" & (month(START_noy) == 12))) |> 
  distinct()
# head(df_oneyear)
```

Test seasonal plot

```{r, fig.height=4, fig.width=6}
# Plot multiple years
ggplot(df_season, aes(x = as_date(DAY))) +
  geom_rect(data = (filter(df_season, SEASON == "Fall")), alpha = 0.2, fill = "#cc5500",
            aes(xmin = START, xmax = END, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_season, SEASON == "Spring")), alpha = 0.2, fill = "#bccbae",
            aes(xmin = START, xmax = END, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_season, SEASON == "Summer")), alpha = 0.2, fill = "#ffbf00",
            aes(xmin = START, xmax = END, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_season, SEASON == "Winter")), alpha = 0.2, fill = "#5d4e62",
            aes(xmin = START, xmax = END, ymin = 0, ymax = 10000))

# Plot one year
ggplot(df_oneyear, aes(x = as_date(DATE))) +
  geom_rect(data = (filter(df_oneyear, SEASON == "Fall")), alpha = 0.2, fill = "#cc5500",
            aes(xmin = START_noy, xmax = END_noy, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_oneyear, SEASON == "Spring")), alpha = 0.2, fill = "#bccbae",
            aes(xmin = START_noy, xmax = END_noy, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_oneyear, SEASON == "Summer")), alpha = 0.2, fill = "#ffbf00",
            aes(xmin = START_noy, xmax = END_noy, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_oneyear, SEASON == "Winter")), alpha = 0.2, fill = "#5d4e62",
            aes(xmin = as_date("2024-01-01"), xmax = END_noy, ymin = 0, ymax = 10000)) +
  geom_rect(data = (filter(df_oneyear, SEASON == "Winter")), alpha = 0.2, fill = "#5d4e62",
            aes(xmin = START_noy, xmax = as_date("2024-12-31"), ymin = 0, ymax = 10000))
```

Combine with existing data frame.

```{r}
# str(counts_long_wtax)
# str(df_season)
counts_long_wtax_wseason <- counts_long_wtax %>% 
  left_join(df_season %>% select(DAY, SEASON, START, END)) %>%
  mutate(day_noyear = paste(MONTH, day(DAY), "2024", sep = "-")) |> 
  mutate(DAY_NOYEAR = mdy(day_noyear)) |> select(-day_noyear)

# head(counts_long_wtax_wseason)

carbon_long_wtax_wseason <- carbon_long_wtax %>% 
  left_join(df_season %>% select(DAY, SEASON, START, END)) %>%
  mutate(day_noyear = paste(MONTH, day(DAY), "2024", sep = "-")) |> 
  mutate(DAY_NOYEAR = mdy(day_noyear)) |> select(-day_noyear)
```

```{r}
# save(carbon_long_wtax_wseason, counts_long_wtax_wseason, df_oneyear, df_season, file = "input-data/data_annotated_wtax_wseason.RData")
```

# Plot all years of data

```{r}
load(file = "input-data/data_annotated_wtax_wseason.RData", verbose = TRUE)
```


```{r}
head(counts_long_wtax_wseason)
```

We want to add information to the dates for when there are Karenia notifications and a data gap. 
```{r}
kar_gap <- counts %>% 
  select(-DAY, -MONTH, -HOUR) %>% 
  pivot_longer(cols = -c(DATE), names_to = "CELL_ID", values_to = "COUNT") %>%
  mutate(ADD = case_when(
    (grepl("Karenia", CELL_ID) & COUNT > 2) ~ "Notification",
    is.na(COUNT) ~ "Data gap"
  )) %>% 
  mutate(WEEK = cut(DATE, "week", start.on.monday = TRUE),
         YEAR = year(as_date(DATE))) %>% 
  select(WEEK, YEAR, ADD) %>% 
  distinct() %>% 
  drop_na()
```



```{r}
counts_byweek <- counts_long_wtax_wseason %>% 
  filter(COURSE_CLASSIFICATION == "Microeukaryote") %>% 
  filter(Phylum != "Cnidaria") %>% 
  # Average the counts PER day for a single Cell ID type
  group_by(DAY, DATE, CELL_ID, SEASON, START, END, DAY_NOYEAR) %>% 
    summarise(COUNT_MEAN_PERDAY = mean(COUNT)) %>% 
  ungroup() %>% 
  # Sum total cells for a single day
  group_by(DAY, DATE, SEASON) %>% 
    summarise(SUM_COUNT_PERDAY = sum(COUNT_MEAN_PERDAY)) %>% 
  ungroup() %>% 
  # Add a column to specify the WEEK - have week start on Mondays
  mutate(WEEK = cut(DATE, "week", start.on.monday = TRUE),
         MONTH = month(as_date(DATE)),
         YEAR = year(as_date(DATE))) %>% 
  # Get mean, min, and max for each week
  group_by(WEEK, SEASON, YEAR) %>% 
    summarise(MEAN_WEEK = mean(SUM_COUNT_PERDAY),
              MAX_WEEK = max(SUM_COUNT_PERDAY),
              MIN_WEEK = min(SUM_COUNT_PERDAY))

head(counts_byweek)
# range(counts_byday$SUM_COUNT_PERDAY)
```

```{r, fig.height=6, fig.width=30}
oneyr_counts <- counts_byweek %>% 
  ggplot(aes(x = as_date(WEEK), y = MEAN_WEEK)) + 
    geom_line(color = "black", alpha = 0.4) +
    geom_linerange(aes(ymin = MIN_WEEK, ymax = MAX_WEEK, color = SEASON, alpha = 0.5), linewidth = 0.5) +
    geom_point(shape = 19, size = 2, aes(color = SEASON)) +
  theme_classic() +
  scale_x_date(date_labels = "%b %y", expand = c(0,0), date_breaks = "3 months", date_minor_breaks = "month") +
  scale_color_manual(values = c("#cc5500","#bccbae","#ffbf00","#5d4e62")) +
  scale_y_log10() +
  labs(x = "", y = bquote("log cell"~ml^-1)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 14),
        axis.title = element_text(color = "black", face = "bold", size = 14),
        axis.text.y = element_text(color = "black", face = "bold", size = 14),
        panel.grid.major = element_line(color = "#d9d9d9", linewidth = 0.3)) +
  geom_point(data = (kar_gap %>% filter(ADD == "Notification")), aes(x = as_date(WEEK), y = 10000), shape = 19, color = "red", alpha = 0.6) +
  geom_point(data = (kar_gap %>% filter(ADD != "Notification")), aes(x = as_date(WEEK), y = 0), size = 3, alpha = 0.6, shape = 17, color = "#bdbdbd")
```
Repeat with carbon data

```{r}
c_byweek <- carbon_long_wtax_wseason %>% 
  filter(COURSE_CLASSIFICATION == "Microeukaryote") %>% 
  filter(Phylum != "Cnidaria") %>% 
  # Average the counts PER day for a single Cell ID type
  group_by(DAY, DATE, CELL_ID, SEASON, START, END, DAY_NOYEAR) %>% 
    summarise(C_MEAN_PERDAY = mean(CARBON)) %>% 
  ungroup() %>% 
  # Sum total cells for a single day
  group_by(DAY, DATE, SEASON) %>% 
    summarise(SUM_C_PERDAY = sum(C_MEAN_PERDAY)) %>% 
  ungroup() %>% 
  # Add a column to specify the WEEK - have week start on Mondays
  mutate(WEEK = cut(DATE, "week", start.on.monday = TRUE),
         MONTH = month(as_date(DATE)),
         YEAR = year(as_date(DATE))) %>% 
  # Get mean, min, and max for each week
  group_by(WEEK, SEASON, YEAR) %>% 
    summarise(MEAN_WEEK = mean(SUM_C_PERDAY),
              MAX_WEEK = max(SUM_C_PERDAY),
              MIN_WEEK = min(SUM_C_PERDAY))

head(c_byweek)
```

```{r, fig.height=6, fig.width=30}
oneyr_c <- c_byweek %>% 
  ggplot(aes(x = as_date(WEEK), y = MEAN_WEEK)) + 
    geom_line(color = "black", alpha = 0.4) +
    geom_linerange(aes(ymin = MIN_WEEK, ymax = MAX_WEEK, color = SEASON, alpha = 0.5), linewidth = 0.5) +
    geom_point(shape = 19, size = 2, aes(color = SEASON)) +
  theme_classic() +
  scale_x_date(date_labels = "%b %y", expand = c(0,0), date_breaks = "3 months", date_minor_breaks = "month") +
  scale_color_manual(values = c("#cc5500","#bccbae","#ffbf00","#5d4e62")) +
  scale_y_log10() +
  labs(x = "", y = bquote("Carbon cell"~ml^-1)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 14),
        axis.title = element_text(color = "black", face = "bold", size = 14),
        axis.text.y = element_text(color = "black", face = "bold", size = 14),
        panel.grid.major = element_line(color = "#d9d9d9", linewidth = 0.3)) +
  geom_point(data = (kar_gap %>% filter(ADD == "Notification")), aes(x = as_date(WEEK), y = 1E+7), shape = 19, color = "red", alpha = 0.6) +
  geom_point(data = (kar_gap %>% filter(ADD != "Notification")), aes(x = as_date(WEEK), y = 0), size = 3, alpha = 0.6, shape = 17, color = "#bdbdbd")
```


```{r, fig.height=10, fig.width=32}
(oneyr_counts + theme(legend.position = "none")) + 
  oneyr_c + 
  patchwork::plot_layout(nrow = 2)
```





# Plot a year of data

```{r}
load(file = "input-data/data_annotated_wtax_wseason.RData", verbose = TRUE)
```

### Plot 1 year of cell count data

```{r}
# YMAX <- max(df_classification_all$MEAN_COUNTS)

counts_1yr <- counts_long_wtax_wseason %>%  
  # Remove any zeroes
  filter(COUNT > 0) %>% 
  # Group by Cell ID to get mean for cell ID for a single day.
  group_by(DAY_NOYEAR, DATE, CELL_ID, SEASON, COURSE_CLASSIFICATION) %>% 
    summarise(PER_DAY_CELL = mean(COUNT)) %>% 
  ungroup() %>% 
  # NOW sum up the different cell types that contribute to the course classification per day
  group_by(DAY_NOYEAR, DATE, SEASON, COURSE_CLASSIFICATION) %>% 
    summarise(PER_DAY_COURSECLASS = sum(PER_DAY_CELL)) %>% 
  ungroup() %>% 
  # Now average by year
  group_by(DAY_NOYEAR, COURSE_CLASSIFICATION, SEASON) %>%  
    summarise(MEAN_COUNTS_1yr = mean(PER_DAY_COURSECLASS)) 
# range(counts_1yr$MEAN_COUNTS_1yr)
YMAX <- max(counts_1yr$MEAN_COUNTS_1yr)
# YMAX
cell_counts_1yr<- counts_1yr %>% 
  ggplot(aes(x = DAY_NOYEAR, y = MEAN_COUNTS_1yr, fill = COURSE_CLASSIFICATION)) + 
  geom_area(position = "stack") +
  theme_classic() +
  scale_x_date(date_labels = "%b", expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x = "", y = "Cell counts") +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 12),
        axis.text.y = element_text(color = "black", face = "bold", size = 12)) +
  geom_rect(xmin = as_date("2024-09-01"), xmax = as_date("2024-11-30"), ymin = (YMAX), ymax = (YMAX+40), alpha = 0.2, fill = "#cc5500") +
  geom_rect(xmin = as_date("2024-03-01"), xmax = as_date("2024-5-31"), ymin = (YMAX), ymax = (YMAX+40), alpha = 0.2, fill = "#bccbae") +
  geom_rect(xmin = as_date("2024-06-01"), xmax = as_date("2024-08-31"), ymin = (YMAX), ymax = (YMAX+40), alpha = 0.2, fill = "#ffbf00") +
  geom_rect(xmin = as_date("2024-12-01"), xmax = as_date("2024-12-31"), ymin = (YMAX), ymax = (YMAX+40), alpha = 0.2, fill = "#5d4e62") +
  geom_rect(xmin = as_date("2024-01-01"), xmax = as_date("2024-02-29"), ymin = (YMAX), ymax = (YMAX+40),, alpha = 0.2, fill = "#5d4e62")
#Spring = March 1 - May 31 
#Summer = June 1 - Aug 31 
#Fall = Sept 1 - Nov 30 
#Winter = Dec 1 - Feb (March 1 (-1))
```

### Plot 1 year of carbon biomass data

```{r}
c_1yr <- carbon_long_wtax_wseason |> 
  # Remove any zeroes
  filter(CARBON > 0) %>% 
  # Group by Cell ID to get mean for cell ID for a single day.
  group_by(DAY_NOYEAR, DATE, CELL_ID, SEASON, COURSE_CLASSIFICATION) %>% 
    summarise(PER_DAY_C = mean(CARBON)) %>% 
  ungroup() %>% 
  # NOW sum up the different cell types that contribute to the course classification per day
  group_by(DAY_NOYEAR, DATE, SEASON, COURSE_CLASSIFICATION) %>% 
    summarise(PER_DAY_COURSECLASS = sum(PER_DAY_C)) %>% 
  ungroup() %>% 
  # Now average by year
  group_by(DAY_NOYEAR, COURSE_CLASSIFICATION, SEASON) %>%  
    summarise(MEAN_C_1yr = mean(PER_DAY_COURSECLASS)) 

carbon_1yr <- c_1yr %>% 
  ggplot(aes(x = DAY_NOYEAR, y = MEAN_C_1yr, fill = COURSE_CLASSIFICATION)) + 
  geom_area(position = "stack") +
  theme_classic() +
  scale_x_date(date_labels = "%b", expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x = "", y = "Carbon biomass") +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 12),
        axis.text.y = element_text(color = "black", face = "bold", size = 12))
# carbon_1yr
```

```{r, fig.height=7, fig.width=7}
(cell_counts_1yr + theme(legend.position = "none")) + carbon_1yr + patchwork::plot_layout(nrow = 2)
```
# Subset only microeukaryotes


## All daily


Look at by hour and season for different supergroups. 
```{r, fig.height=8, fig.width=10}
# head(counts_long_wtax_wseason)
# counts_long_wtax_wseason
counts_long_wtax_wseason |> 
  filter(COURSE_CLASSIFICATION == "Microeukaryote") %>% 
  filter(Phylum != "Cnidaria") %>% 
  # Remove any zeroes
  filter(COUNT > 0 | is.na(COUNT)) %>% 
  # Get average for a given hour in the same month and season for an individual day.
  group_by(HOUR, SEASON, Supergroup, Phylum) %>% 
    summarise(MEAN_COUNT_DAILY = mean(COUNT),
              MAX_COUNT_DAILY = max(COUNT),
              MIN_COUNT_DAILY = min(COUNT)) %>% 
  ggplot(aes(x = (HOUR), y = MEAN_COUNT_DAILY, color = SEASON)) +
    geom_path(aes(group = Phylum)) +
    geom_point(shape = 19) +
    facet_grid(rows = vars(Supergroup), cols = vars(SEASON), scales = "free") +
  theme_classic() +
  scale_color_manual(values = c("#cc5500","#bccbae","#ffbf00","#5d4e62")) +
  scale_y_log10() +
  labs(x = "", y = bquote("log cell"~ml^-1)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 10),
        axis.title = element_text(color = "black", face = "bold", size = 11),
        axis.text.y = element_text(color = "black", face = "bold", size = 10),
        panel.grid.major = element_line(color = "#d9d9d9", linewidth = 0.3))

```

Each line represents a phylum, so there are some withe more variability than others. We also know that cell types are not equally represented across the supergroups in the IFCB data, therefore, we need to focus on the stramenopiles and alveolata vs. other supergroups. 

```{r, fig.height=8, fig.width=10}
alv_stram <- c("Stramenopiles", "Alveolata")
# counts_long_wtax_wseason
counts_long_wtax_wseason |> 
  filter(COURSE_CLASSIFICATION == "Microeukaryote") %>% 
  filter(Phylum != "Cnidaria") %>% 
  filter(!(Supergroup %in% alv_stram)) %>% 
  # Remove any zeroes
  filter(COUNT > 0 | is.na(COUNT)) %>% 
  # Get average for a given hour in the same month and season for an individual day.
  group_by(HOUR, SEASON, Supergroup, Phylum, CELL_ID) %>% 
    summarise(MEAN_COUNT_DAILY = mean(COUNT),
              MAX_COUNT_DAILY = max(COUNT),
              MIN_COUNT_DAILY = min(COUNT)) %>% 
  ggplot(aes(x = (HOUR), y = MEAN_COUNT_DAILY, color = SEASON)) +
    geom_path(aes(group = CELL_ID)) +
    geom_point(shape = 19) +
    facet_grid(rows = vars(Supergroup), cols = vars(SEASON), scales = "free") +
  theme_classic() +
  scale_color_manual(values = c("#cc5500","#bccbae","#ffbf00","#5d4e62")) +
  scale_y_log10() +
  labs(x = "", y = bquote("log cell"~ml^-1)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 10),
        axis.title = element_text(color = "black", face = "bold", size = 11),
        axis.text.y = element_text(color = "black", face = "bold", size = 10),
        panel.grid.major = element_line(color = "#d9d9d9", linewidth = 0.3))
```

# Focus on Alveolata, Stramenopiles, & Haptophytes
```{r}
head(counts_long_wtax_wseason)
```

```{r}
alveolata_counts_1yr <- counts_long_wtax_wseason %>%  
  filter(Supergroup == "Alveolata") %>% 
  # Remove any zeroes
  filter(COUNT > 0) %>% 
  # Group by Cell ID to get mean for cell ID for a single day.
  group_by(DAY_NOYEAR, DATE, CELL_ID, SEASON, Phylum, Class, Order, Family, Genus) %>% 
    summarise(PER_DAY_CELL = mean(COUNT)) %>% 
  ungroup() %>% 
  # Use this if grouping across cell IDs
  # group_by(DAY_NOYEAR, DATE, SEASON, Phylum, Class, Order, Family, Genus, CELL_ID) %>% 
  #   summarise(PER_DAY_CELLID = sum(PER_DAY_CELL)) %>% 
  # ungroup() %>% 
  # Now average by year
  group_by(DAY_NOYEAR, CELL_ID, SEASON, Phylum, Class, Order, Family, Genus) %>%  
    summarise(MEAN_COUNTS_1yr = mean(PER_DAY_CELL)) 
#
head(alveolata_counts_1yr)
unique(alveolata_counts_1yr$Phylum) # dinos and ciliates
unique(alveolata_counts_1yr$Class) # colors?
unique(alveolata_counts_1yr$Order) 
max(alveolata_counts_1yr$DAY_NOYEAR)

labels <- alveolata_counts_1yr %>%
  filter(DAY_NOYEAR == "2024-12-31")
# head(labels)
```
```{r, fig.height=30, fig.width=8}
alveolata_counts_1yr %>% 
  # filter(Phylum == "Ciliophora") %>%
  ggplot(aes(x = DAY_NOYEAR, y = MEAN_COUNTS_1yr, fill = Order)) + 
  geom_line(color = "black", alpha = 0.4) +
    geom_point(shape = 21, size = 2, color = "black") +
  theme_classic() +
  scale_x_date(date_labels = "%b", expand = c(0,0)) +
  # scale_y_continuous(expand = c(0,0)) +
  scale_y_log10() +
  facet_grid(rows = vars(Class), scales = "free") +
  ggrepel::geom_label_repel(data = labels, aes(label = CELL_ID, x = DAY_NOYEAR, y = MEAN_COUNTS_1yr), nudge_x = 0.1, inherit.aes=F, na.rm = FALSE) +
  labs(x = "", y = bquote("Cell"~ml^-1)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.text.x = element_text(color = "black", face = "bold", size = 12),
        axis.text.y = element_text(color = "black", face = "bold", size = 12))
```


## Ochrophyta
Diatoms

- Cell counts over the entire dataset.
- Mean, min, max for each day / week / month?
- carbon per cell
- Diversity over time

Analyses:
PCA or CCA plot